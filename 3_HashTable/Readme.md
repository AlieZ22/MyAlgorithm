## 基础概念

首先，哈希表 是根据关键码进行直接访问的数据结构，一个数组也可以是一个哈希表，索引下标为关键码，数组中的元素为值。

哈希表能够处理的问题：快速判断（O(1)）一个元素是否出现在集合中【牺牲空间换取时间】。

### **哈希函数**

如下图所示，哈希函数将学生姓名转化为数值，就成功将学生名字（string）映射成哈希表上的索引数字了。

![哈希函数](https://img-blog.csdnimg.cn/2021010423484818.png)

为防止`hashCode`计算得到的值大于哈希表的大小，需要一个取模的运算，保证所有得到的索引都落在哈希表的范围中。

但是这样，又会产生新的问题，即会存在有多个不同学生的名字同时映射到哈希表中的同一个位置上。

### **哈希碰撞**

上述问题，就被称为哈希碰撞。解决碰撞有很多种方式，这里说常见的两种：`拉链法` 和 `线性探测法`。

拉链法：哈希表中元素为链表，冲突元素的下标相同，放在同一个链表中。

![拉链法](https://img-blog.csdnimg.cn/20210104235015226.png))

拉链法要选择适当的哈希表大小，这样既不会因为数组空闲而浪费内存，也不会因为链表太长而在查找上浪费时间。

线性探测法：依靠哈希表中的空位解决碰撞问题，要保证 哈希表的大小 大于 数据量。

具体方法就是，如果这个索引位置被占用了，就找下一个空位。

![线性探测法](https://img-blog.csdnimg.cn/20210104235109950.png)

### **常见的三种哈希结构**

一般用哈希表解决问题时，会选择如下三种数据结构来表示哈希表：

- 数组
- set（集合）
- map（映射表）

c++中，提供了不同的set和map实现，其底层实现和优劣总结在下表中：

| 集合              | 底层实现 | key是否有序 | key是否重复 | key是否可修改 | 查询效率 | 增删效率 |
| ----------------- | -------- | ----------- | ----------- | ------------- | -------- | -------- |
| std::set          | 红黑树   | 有序        | 否          | 否            | O(log n) | O(log n) |
| std::multiset     | 红黑树   | 有序        | 是          | 否            | O(log n) | O(log n) |
| std:unordered_set | 哈希表   | 无序        | 否          | 否            | O(1)     | O(1)     |

说明：红黑树是一种平衡二叉树，所以key值有序，但是不能修改，否则会导致整棵树的错乱，所以只能增加或删除。

| 映射表             | 底层实现 | key是否有序 | key是否重复 | key是否可修改 | 查询效率 | 增删效率 |
| ------------------ | -------- | ----------- | ----------- | ------------- | -------- | -------- |
| std::map           | 红黑树   | 有序        | 否          | 否            | O(log n) | O(log n) |
| std::multimap      | 红黑树   | 有序        | 是          | 否            | O(log n) | O(log n) |
| std::unordered_map | 哈希表   | 无序        | 否          | 否            | O(1）    | O(1)     |

### 

### 小结

当我们遇到了要**快速判断一个元素是否出现在集合里**的时候，就要考虑哈希法。

但是哈希法也是**牺牲了空间换取了时间**，因为需要使用额外的数组、set或者map来存放数据，才能实现快速的查找。



## 常见题型

### 异位词

所谓异位词，就是两个词（如string）的字母构成是一样的，字母使用种类和每个字母对应的使用次数都相同，就是排序不同。

对于异位词相关的题目，常见的有两种方式解：

1. 排序：排完序之后的异位词是一样的了。优点：简单易懂；缺点：排序的时间开销比较高。
2. 哈希表记录：记录每个字母出现的次数，来判断是否为异位词。字母的范围比较小，可以用个string来标记a-z对应出现次数。优点：灵活，还可以配合滑动窗口；缺点：使用了额外的空间。