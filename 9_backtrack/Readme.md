## 回溯题型分类大纲

![回溯题型](https://code-thinking-1253855093.file.myqcloud.com/pics/20210219192050666.png)

回溯，是一种搜索的方式。回溯是递归的副产物，回溯函数也是一个**递归函数**。其本质是穷举所有可能，然后选出想要的答案。

一般来说，回溯法可以解决如下几种问题：

- 组合问题：N个数里面按一定规则找出k个数的集合
- 切割问题：一个字符串按一定规则有几种切割方式
- 子集问题：一个N个数的集合里有多少符合条件的子集
- 排列问题：N个数按一定规则全排列，有几种排列方式
- 棋盘问题：N皇后，解数独等

这些问题中需要注意区分的是，<u>组合不强调元素顺序，而排序是强调元素顺序的</u>。

那么应该如何理解回溯法呢？

其实，回溯解决的问题都可以抽象为树形结构，集合的大小构成了树的宽度，递归的深度构成树的深度，递归要有终止条件，所有必然是一棵高度有限的树（N叉树）。



## 回溯法模板

回溯算法模板可以总结为 回溯三部曲：

1. 回溯函数的返回值和参数

   一般将回溯函数取名为 `backtrack` , 其返回值一般为void，参数的话需要看具体的逻辑来确定，需要什么参数再填什么参数。

   ```c++
   void backtrack(参数列表);
   ```

2. 回溯函数的终止条件

   回溯可以看成是树形结构，一般终止条件为找到可能满足条件的一组答案，也就是搜索到了叶子节点。

   ```c++
   if(终止条件){
       存放相关结果;
       return ;
   }
   ```

3. 回溯搜索的遍历过程

   使用横向+纵向两个方向来遍历所有情况

   ![回溯搜索过程](https://code-thinking-1253855093.file.myqcloud.com/pics/20210130173631174.png)

   其遍历过程的伪代码如下：

   ```c++
   for(选择: 本层集合中的元素){       // 遍历-横向
       处理节点;
       backtrack(路径，选择列表);    // 递归-纵向
       回溯，撤销处理;
   }
   ```

那么综合一下，回溯法的算法模板如下：

```c++
void backtrack(参数列表){
    if(终止条件){
        存放相关结果;
        return ;
    }
    for(选择: 本层集合中的元素){       // 遍历-横向
        处理节点;
        backtrack(路径，选择列表);    // 递归-纵向
        回溯，撤销处理;
    }
}
```

